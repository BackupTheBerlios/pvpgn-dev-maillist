<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [pvpgn-dev] r311 - in trunk/pvpgn: Win32-Projects src/bnetd	src/common
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/pvpgn-dev/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:pvpgn-dev%40lists.berlios.de?Subject=Re%3A%20%5Bpvpgn-dev%5D%20r311%20-%20in%20trunk/pvpgn%3A%20Win32-Projects%20src/bnetd%0A%09src/common&In-Reply-To=%3C200708131403.l7DE3Hbn018419%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000287.html">
   <LINK REL="Next"  HREF="000289.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[pvpgn-dev] r311 - in trunk/pvpgn: Win32-Projects src/bnetd	src/common</H1>
    <B>svn at svn.berlios.de</B> 
    <A HREF="mailto:pvpgn-dev%40lists.berlios.de?Subject=Re%3A%20%5Bpvpgn-dev%5D%20r311%20-%20in%20trunk/pvpgn%3A%20Win32-Projects%20src/bnetd%0A%09src/common&In-Reply-To=%3C200708131403.l7DE3Hbn018419%40sheep.berlios.de%3E"
       TITLE="[pvpgn-dev] r311 - in trunk/pvpgn: Win32-Projects src/bnetd	src/common">svn at svn.berlios.de
       </A><BR>
    <I>Mon Aug 13 16:03:17 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000287.html">[pvpgn-dev] r310 - trunk/pvpgn/src/bnetd
</A></li>
        <LI>Next message: <A HREF="000289.html">[pvpgn-dev] r312 - trunk/pvpgn/conf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#288">[ date ]</a>
              <a href="thread.html#288">[ thread ]</a>
              <a href="subject.html#288">[ subject ]</a>
              <a href="author.html#288">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: pelish
Date: 2007-08-13 16:03:10 +0200 (Mon, 13 Aug 2007)
New Revision: 311

Added:
   trunk/pvpgn/src/bnetd/handle_apireg.cpp
   trunk/pvpgn/src/bnetd/handle_apireg.h
   trunk/pvpgn/src/common/wolhash.cpp
   trunk/pvpgn/src/common/wolhash.h
Modified:
   trunk/pvpgn/Win32-Projects/PvPGN.dev
   trunk/pvpgn/Win32-Projects/PvPGNConsole.dev
   trunk/pvpgn/src/bnetd/handle_irc_common.cpp
   trunk/pvpgn/src/bnetd/irc.cpp
Log:
add missing API Register service files, fix of two small bugs on handle_irc_common.cpp and irc.cpp

Modified: trunk/pvpgn/Win32-Projects/PvPGN.dev
===================================================================
--- trunk/pvpgn/Win32-Projects/PvPGN.dev	2007-08-13 10:57:49 UTC (rev 310)
+++ trunk/pvpgn/Win32-Projects/PvPGN.dev	2007-08-13 14:03:10 UTC (rev 311)
@@ -1,7 +1,7 @@
 [Project]
 FileName=PvPGN.dev
 Name=PvPGN
-UnitCount=274
+UnitCount=278
 Type=0
 Ver=1
 ObjFiles=
@@ -2787,3 +2787,43 @@
 OverrideBuildCmd=0
 BuildCmd=
 
+[Unit275]
+FileName=..\src\common\wolhash.h
+CompileCpp=1
+Folder=common/Header Files
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit276]
+FileName=..\src\common\wolhash.cpp
+CompileCpp=1
+Folder=common/Source Files
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit277]
+FileName=..\src\bnetd\handle_apireg.h
+CompileCpp=1
+Folder=bnetd/Header Files
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit278]
+FileName=..\src\bnetd\handle_apireg.cpp
+CompileCpp=1
+Folder=bnetd/Source Files
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+

Modified: trunk/pvpgn/Win32-Projects/PvPGNConsole.dev
===================================================================
--- trunk/pvpgn/Win32-Projects/PvPGNConsole.dev	2007-08-13 10:57:49 UTC (rev 310)
+++ trunk/pvpgn/Win32-Projects/PvPGNConsole.dev	2007-08-13 14:03:10 UTC (rev 311)
@@ -1,7 +1,7 @@
 [Project]
 FileName=PvPGNConsole.dev
 Name=PvPGNConsole
-UnitCount=268
+UnitCount=272
 Type=1
 Ver=1
 ObjFiles=
@@ -2727,3 +2727,42 @@
 OverrideBuildCmd=0
 BuildCmd=
 
+[Unit269]
+FileName=..\src\common\wolhash.h
+CompileCpp=1
+Folder=common/Header Files
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit270]
+FileName=..\src\common\wolhash.cpp
+CompileCpp=1
+Folder=common/Source Files
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit271]
+FileName=..\src\bnetd\handle_apireg.h
+CompileCpp=1
+Folder=bnetd/Header Files
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=
+
+[Unit272]
+FileName=..\src\bnetd\handle_apireg.cpp
+CompileCpp=1
+Folder=bnetd/Source Files
+Compile=1
+Link=1
+Priority=1000
+OverrideBuildCmd=0
+BuildCmd=

Added: trunk/pvpgn/src/bnetd/handle_apireg.cpp
===================================================================
--- trunk/pvpgn/src/bnetd/handle_apireg.cpp	2007-08-13 10:57:49 UTC (rev 310)
+++ trunk/pvpgn/src/bnetd/handle_apireg.cpp	2007-08-13 14:03:10 UTC (rev 311)
@@ -0,0 +1,897 @@
+/*
+ * Copyright (C) 2007  Pelish (<A HREF="https://lists.berlios.de/mailman/listinfo/pvpgn-dev">pelish at gmail.com</A>)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#define APIREGISTER_INTERNAL_ACCESS
+#include &quot;common/setup_before.h&quot;
+#include &quot;handle_apireg.h&quot;
+
+#include &lt;cstring&gt;
+#include &lt;cctype&gt;
+#include &lt;cstdlib&gt;
+
+#include &quot;common/eventlog.h&quot;
+#include &quot;common/bnethash.h&quot;
+#include &quot;common/wolhash.h&quot;
+#include &quot;common/list.h&quot;
+#include &quot;common/packet.h&quot;
+
+#include &quot;prefs.h&quot;
+#include &quot;irc.h&quot;
+#include &quot;account.h&quot;
+#include &quot;account_wrap.h&quot;
+#include &quot;message.h&quot;
+#include &quot;server.h&quot;
+#include &quot;common/setup_after.h&quot;
+
+namespace pvpgn
+{
+
+namespace bnetd
+{
+
+typedef int (* t_apireg_tag)(t_apiregmember * apiregmember, char * param);
+
+static t_list * apireglist_head=NULL;
+
+typedef struct {
+	char  * apireg_tag_string;
+	t_apireg_tag  apireg_tag_handler;
+} t_apireg_tag_table_row;
+
+static int _handle_email_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_bmonth_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_bday_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_byear_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_langcode_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_sku_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_ver_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_serial_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_sysid_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_syscheck_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_oldnick_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_oldpass_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_newnick_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_newpass_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_newpass2_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_parentemail_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_newsletter_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_shareinfo_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_request_apiregtag(t_apiregmember * apiregmember, char * param);
+static int _handle_end_apiregtag(t_apiregmember * apiregmember, char * param);
+
+static const t_apireg_tag_table_row apireg_tag_table[] =
+{
+	{ &quot;EMAIL&quot;		, _handle_email_apiregtag },
+	{ &quot;BMONTH&quot;		, _handle_bmonth_apiregtag },
+	{ &quot;BDAY&quot;		, _handle_bday_apiregtag },
+	{ &quot;BYEAR&quot;		, _handle_byear_apiregtag },
+	{ &quot;LANGCODE&quot;	, _handle_langcode_apiregtag },
+	{ &quot;SKU&quot;	 		, _handle_sku_apiregtag },
+	{ &quot;VER&quot;	    	, _handle_ver_apiregtag },
+	{ &quot;SERIAL&quot;		, _handle_serial_apiregtag },
+	{ &quot;SYSID&quot;		, _handle_sysid_apiregtag },
+	{ &quot;SYSCHECK&quot;	, _handle_syscheck_apiregtag },
+	{ &quot;OLDNICK&quot;		, _handle_oldnick_apiregtag },
+	{ &quot;OLDPASS&quot;		, _handle_oldpass_apiregtag },
+	{ &quot;NEWNICK&quot;		, _handle_newnick_apiregtag },
+	{ &quot;NEWPASS&quot;		, _handle_newpass_apiregtag },
+	{ &quot;NEWPASS2&quot;	, _handle_newpass2_apiregtag },
+	{ &quot;PARENTEMAIL&quot;	, _handle_parentemail_apiregtag },
+	{ &quot;NEWSLETTER&quot;	, _handle_newsletter_apiregtag },
+	{ &quot;SHAREINFO&quot;	, _handle_shareinfo_apiregtag },
+	{ &quot;REQUEST&quot;		, _handle_request_apiregtag },
+	{ &quot;END&quot; 		, _handle_end_apiregtag },
+
+	{ NULL			, NULL }
+};
+
+static t_apiregmember * apiregmember_create(t_connection * conn)
+{
+    t_apiregmember * temp;
+
+	if (!conn) {
+	  ERROR0(&quot;got NULL conn&quot;);
+	  return NULL;
+	}
+
+    temp = (t_apiregmember*)xmalloc(sizeof(t_apiregmember));
+
+    eventlog(eventlog_level_info,__FUNCTION__,&quot;creating apiregmember&quot;);
+
+    temp-&gt;conn = conn;
+    temp-&gt;email = NULL;
+    temp-&gt;bday = NULL;
+    temp-&gt;bmonth = NULL;
+    temp-&gt;byear = NULL;
+    temp-&gt;langcode = NULL;   //&quot;0&quot;;
+    temp-&gt;sku = NULL;
+    temp-&gt;ver = NULL;
+    temp-&gt;serial = NULL;
+    temp-&gt;sysid = NULL;   //&quot;((SysID))&quot;;
+    temp-&gt;syscheck = NULL;   //&quot;((SysCheck))&quot;;
+    temp-&gt;oldnick = NULL;
+    temp-&gt;oldpass = NULL;
+    temp-&gt;newnick = NULL;   //&quot;((NewPass))&quot;;
+    temp-&gt;newpass = NULL;   //&quot;((NewPass))&quot;;
+    temp-&gt;newpass2 = NULL;   //&quot;((NewPass2))&quot;;
+    temp-&gt;parentemail = NULL;   //&quot;((ParentEmail))&quot;;
+    temp-&gt;newsletter = false;
+    temp-&gt;shareinfo = false;
+    temp-&gt;request = NULL;   //&quot;((Request))&quot;;
+
+    list_append_data(apireglist_head,temp);
+
+    return temp;
+}
+
+static int apiregmember_destroy(t_apiregmember * apiregmember, t_elem ** curr)
+{
+    eventlog(eventlog_level_info,__FUNCTION__,&quot;destroying apiregmember&quot;);
+
+    if (!apiregmember) {
+	    ERROR0(&quot;got NULL apiregmember&quot;);
+	    return -1;
+    }
+    
+    if (list_remove_data(apireglist_head,apiregmember,curr)&lt;0){
+        ERROR0(&quot;could not remove item from list&quot;);
+        return -1;
+    }
+
+    if (apiregmember-&gt;email)
+        xfree((void *)apiregmember-&gt;email); /* avoid warning */
+
+    if (apiregmember-&gt;bday)
+        xfree((void *)apiregmember-&gt;bday); /* avoid warning */
+
+    if (apiregmember-&gt;bmonth)
+        xfree((void *)apiregmember-&gt;bmonth); /* avoid warning */
+
+    if (apiregmember-&gt;byear)
+        xfree((void *)apiregmember-&gt;byear); /* avoid warning */
+
+    if (apiregmember-&gt;langcode)
+        xfree((void *)apiregmember-&gt;langcode); /* avoid warning */
+
+    if (apiregmember-&gt;sku)
+        xfree((void *)apiregmember-&gt;sku); /* avoid warning */
+
+    if (apiregmember-&gt;ver)
+        xfree((void *)apiregmember-&gt;ver); /* avoid warning */
+
+    if (apiregmember-&gt;serial)
+        xfree((void *)apiregmember-&gt;serial); /* avoid warning */
+
+    if (apiregmember-&gt;sysid)
+        xfree((void *)apiregmember-&gt;sysid); /* avoid warning */
+
+    if (apiregmember-&gt;syscheck)
+        xfree((void *)apiregmember-&gt;syscheck); /* avoid warning */
+
+    if (apiregmember-&gt;oldnick)
+        xfree((void *)apiregmember-&gt;oldnick); /* avoid warning */
+
+    if (apiregmember-&gt;oldpass)
+        xfree((void *)apiregmember-&gt;oldpass); /* avoid warning */
+
+    if (apiregmember-&gt;newnick)
+        xfree((void *)apiregmember-&gt;newnick); /* avoid warning */
+
+    if (apiregmember-&gt;newpass)
+        xfree((void *)apiregmember-&gt;newpass); /* avoid warning */
+
+    if (apiregmember-&gt;newpass2)
+        xfree((void *)apiregmember-&gt;newpass2); /* avoid warning */
+
+    if (apiregmember-&gt;parentemail)
+        xfree((void *)apiregmember-&gt;parentemail); /* avoid warning */
+
+//    if (apiregmember-&gt;newsletter)
+//        xfree((void *)apiregmember-&gt;newsletter); /* avoid warning */
+
+//    if (apiregmember-&gt;shareinfo)
+//        xfree((void *)apiregmember-&gt;shareinfo); /* avoid warning */
+
+    if (apiregmember-&gt;request)
+        xfree((void *)apiregmember-&gt;request); /* avoid warning */
+
+    xfree(apiregmember);
+    
+    return 0;
+}
+
+static t_connection * apiregmember_get_conn(t_apiregmember const * apiregmember)
+{
+	if (!apiregmember) {
+	  ERROR0(&quot;got NULL apiregmember&quot;);
+	  return NULL;
+	}
+
+    return apiregmember-&gt;conn;
+}
+
+static char const * apiregmember_get_email(t_apiregmember const * apiregmember)
+{
+	if (!apiregmember) {
+	  ERROR0(&quot;got NULL apiregmember&quot;);
+	  return NULL;
+	}
+
+    return apiregmember-&gt;email;
+}
+
+static char const * apiregmember_get_bday(t_apiregmember const * apiregmember)
+{
+	if (!apiregmember) {
+	  ERROR0(&quot;got NULL apiregmember&quot;);
+	  return NULL;
+	}
+
+    return apiregmember-&gt;bday;
+}
+
+static char const * apiregmember_get_bmonth(t_apiregmember const * apiregmember)
+{
+	if (!apiregmember) {
+	  ERROR0(&quot;got NULL apiregmember&quot;);
+	  return NULL;
+	}
+
+    return apiregmember-&gt;bmonth;
+}
+
+static char const * apiregmember_get_newnick(t_apiregmember const * apiregmember)
+{
+	if (!apiregmember) {
+	  ERROR0(&quot;got NULL apiregmember&quot;);
+	  return NULL;
+	}
+
+    return apiregmember-&gt;newnick;
+}
+
+static char const * apiregmember_get_newpass(t_apiregmember const * apiregmember)
+{
+	if (!apiregmember) {
+	  ERROR0(&quot;got NULL apiregmember&quot;);
+	  return NULL;
+	}
+
+    return apiregmember-&gt;newpass;
+}
+
+static char const * apiregmember_get_request(t_apiregmember const * apiregmember)
+{
+	if (!apiregmember) {
+	  ERROR0(&quot;got NULL apiregmember&quot;);
+	  return NULL;
+	}
+
+    return apiregmember-&gt;request;
+}
+
+extern int apireglist_create(void)
+{
+    apireglist_head = list_create();
+    return 0;
+}
+
+extern int apireglist_destroy(void)
+{
+    t_apiregmember * apiregmember;
+    t_elem * curr;
+
+    if (apireglist_head) {
+	    LIST_TRAVERSE(apireglist_head,curr) {
+	       if (!(apiregmember = (t_apiregmember*)elem_get_data(curr))) {
+		       ERROR0(&quot;channel list contains NULL item&quot;);
+		       continue;
+	       }
+	       apiregmember_destroy(apiregmember,&amp;curr);
+	    }
+
+	    if (list_destroy(apireglist_head)&lt;0)
+            return -1;
+        apireglist_head = NULL;
+    }
+
+    return 0;
+}
+
+extern t_list * apireglist(void)
+{
+    return apireglist_head;
+}
+
+static t_apiregmember * apireglist_find_apiregmember_by_conn(t_connection * conn)
+{
+    t_apiregmember * apiregmember;
+    t_elem * curr;
+
+    if (!conn) {
+        ERROR0(&quot;got NULL conn&quot;);
+        return NULL;
+    }
+
+    LIST_TRAVERSE(apireglist(),curr) {
+   	    t_apiregmember * apiregmember = (t_apiregmember *)elem_get_data(curr);
+   	    if (conn == apiregmember_get_conn(apiregmember)) {
+            return apiregmember;
+        }
+    }
+
+    return NULL;
+}
+
+static int handle_apireg_tag(t_apiregmember * apiregmember, char const * tag, char * param)
+{
+  t_apireg_tag_table_row const *p;
+
+  for (p = apireg_tag_table; p-&gt;apireg_tag_string != NULL; p++) {
+    if (strcasecmp(tag, p-&gt;apireg_tag_string)==0) {
+	  if (p-&gt;apireg_tag_handler != NULL)
+		  return ((p-&gt;apireg_tag_handler)(apiregmember,param));
+	}
+  }
+  return -1;
+}
+
+static int handle_apireg_line(t_connection * conn, char const * apiregline)
+{
+	/* &lt;command&gt;=[param] */
+    char * line; /* copy of apiregline */
+    char * tag = NULL; /* mandatory */
+    char * param = NULL; /* param of tag */
+	t_apiregmember * apiregmember = apireglist_find_apiregmember_by_conn(conn);
+
+    if (!conn) {
+	    ERROR0(&quot;got NULL connection&quot;);
+	    return -1;
+    }
+    if (!apiregline) {
+	    ERROR0(&quot;got NULL apiregline&quot;);
+	    return -1;
+    }
+    if (apiregline[0] == '\0') {
+	    ERROR0(&quot;got empty apiregline&quot;);
+	    return -1;
+    }
+
+    if (std::strlen(apiregline)&gt;254) {
+        char * tmp = (char *)apiregline;
+	    WARN0(&quot;line to long, truncation...&quot;);
+	    tmp[254]='\0';
+    }
+    
+    if (!apiregmember) {
+        apiregmember = apiregmember_create(conn);
+    }
+
+    line = xstrdup(apiregline);
+
+    /* split the message */
+    
+    tag = line;
+    param = std::strchr(tag,'=');
+    if (param)
+        *param++ = '\0';
+
+	eventlog(eventlog_level_error,__FUNCTION__,&quot;(%s)NICK:%s/BMONTH:%s/BDAY:%s&quot;,tag,apiregmember_get_newnick(apiregmember),apiregmember_get_bmonth(apiregmember),apiregmember_get_bday(apiregmember));
+    
+    if (handle_apireg_tag(apiregmember, tag, param)!=-1) {}
+    
+    
+    xfree(line);
+    
+    return 0;
+}
+
+extern int handle_apireg_packet(t_connection * conn, t_packet const * const packet)
+{
+    unsigned int i;
+    char apiregline[MAX_IRC_MESSAGE_LEN];
+    char const * data;
+
+    if (!packet) {
+	    ERROR0(&quot;got NULL packet&quot;);
+	    return -1;
+    }
+    if (conn_get_class(conn) != conn_class_apireg) {
+	    ERROR0(&quot;FIXME: handle_apireg_packet without any reason (conn-&gt;class != conn_class_apireg)&quot;);
+	    return -1;
+    }
+
+    /* eventlog(eventlog_level_debug,__FUNCTION__,&quot;got \&quot;%s\&quot;&quot;,packet_get_raw_data_const(packet,0)); */
+
+    std::memset(apiregline,0,sizeof(apiregline));
+
+    data = conn_get_ircline(conn); /* fetch current status */
+    if (data)
+	    std::strcpy(apiregline,data);
+
+    unsigned apiregpos = std::strlen(apiregline);
+    data = (const char *)packet_get_raw_data_const(packet,0);
+
+    for (i=0; i &lt; packet_get_size(packet); i++) {
+	    if ((data[i] == '\r')||(data[i] == '\0')) {
+	          /* kindly ignore \r and NUL ... */
+	    }
+        else if (data[i] == '\n') {
+	         /* end of line */
+	         handle_apireg_line(conn,apiregline);
+	         std::memset(apiregline,0,sizeof(apiregline));
+	         apiregpos = 0;
+        }
+        else {
+	         if (apiregpos &lt; MAX_IRC_MESSAGE_LEN-1)
+		         apiregline[apiregpos++] = data[i];
+	         else {
+		         apiregpos++; /* for the statistic :) */
+	    	     WARN2(&quot;[%d] client exceeded maximum allowed message length by %d characters&quot;,conn_get_socket(conn),apiregpos-MAX_IRC_MESSAGE_LEN);
+		         if (apiregpos &gt; 100 + MAX_IRC_MESSAGE_LEN) {
+		              /* automatic flood protection */
+		             ERROR1(&quot;[%d] excess flood&quot;,conn_get_socket(conn));
+		             return -1;
+		         }
+	         }
+	    }
+    }
+    conn_set_ircline(conn,apiregline); /* write back current status */
+    return 0;
+}
+
+static int apireg_send(t_connection * conn, char const * command)
+{
+    t_packet * p;
+    char data[MAX_IRC_MESSAGE_LEN+1];
+    unsigned len;
+    t_apiregmember * apiregmember;
+    t_elem * curr;
+
+    p = packet_create(packet_class_raw);
+
+    if (command)
+        len = (std::strlen(command));
+
+   	if (len &gt; MAX_IRC_MESSAGE_LEN) {
+	    ERROR1(&quot;message to send is too large (%u bytes)&quot;,len);
+	    return -1;
+	}
+	else {
+	    std::sprintf(data,&quot;%s&quot;,command);
+    }
+    
+    packet_set_size(p,0);
+    packet_append_data(p,data,len);
+    ERROR2(&quot;[%d] sent \&quot;%s\&quot;&quot;,conn_get_socket(conn),data);
+    conn_push_outqueue(conn,p);
+    packet_del_ref(p);
+
+    /* In apiregister server we must destroy apiregmember and connection after send packet */
+
+    LIST_TRAVERSE(apireglist(),curr) {
+        t_apiregmember * tempapireg = (t_apiregmember*)elem_get_data(curr);
+
+        if (conn == apiregmember_get_conn(tempapireg))
+            apiregmember_destroy(tempapireg, &amp;curr);
+   }
+
+    conn_set_state(conn, conn_state_destroy);
+
+    return 0;
+}
+
+static int _handle_email_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+	
+    if (apiregmember-&gt;email)
+   	   xfree((void *)apiregmember-&gt;email);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;email = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_bmonth_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    if (apiregmember-&gt;bmonth)
+       xfree((void *)apiregmember-&gt;bmonth);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;bmonth = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_bday_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    if (apiregmember-&gt;bday)
+    	xfree((void *)apiregmember-&gt;bday);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;bday = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_byear_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    if (apiregmember-&gt;byear)
+    	xfree((void *)apiregmember-&gt;byear);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;byear = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_langcode_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    if (apiregmember-&gt;langcode)
+    	xfree((void *)apiregmember-&gt;langcode);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;langcode = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_sku_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+/* We have SKUs */
+
+	return 0;
+}
+
+static int _handle_ver_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+/* We have VERs */
+
+	return 0;
+}
+
+static int _handle_serial_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    /* We have SERIALs */
+
+	return 0;
+}
+
+static int _handle_sysid_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    if (apiregmember-&gt;sysid)
+    	xfree((void *)apiregmember-&gt;sysid);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;sysid = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_syscheck_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    if (apiregmember-&gt;syscheck)
+    	xfree((void *)apiregmember-&gt;syscheck);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;syscheck = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_oldnick_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    /* We have OLDNICKs */
+
+	return 0;
+}
+
+static int _handle_oldpass_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    /* We have OLDPASSs */
+
+	return 0;
+}
+
+static int _handle_newnick_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    if (apiregmember-&gt;newnick)
+    	xfree((void *)apiregmember-&gt;newnick); 
+
+	if (param)
+ 	   apiregmember-&gt;newnick = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_newpass_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    if (apiregmember-&gt;newpass)
+    	xfree((void *)apiregmember-&gt;newpass);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;newpass = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_newpass2_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    if (apiregmember-&gt;newpass2)
+    	xfree((void *)apiregmember-&gt;newpass2);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;newpass2 = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_parentemail_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+	
+    if (apiregmember-&gt;parentemail)
+    	xfree((void *)apiregmember-&gt;parentemail);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;parentemail = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_newsletter_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+/*	if (param) {
+	   if (std::strcmp(param, &quot;1&quot;) == 0)
+           apiregmember-&gt;newsletter = true;
+       else
+           apiregmember-&gt;newsletter = false;
+    }*/
+
+	return 0;
+}
+
+static int _handle_shareinfo_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+/*	if (param) {
+	   if (std::strcmp(param, &quot;1&quot;) == 0)
+           apiregmember-&gt;shareinfo = true;
+       else
+           apiregmember-&gt;shareinfo = false;
+    }*/
+
+	return 0;
+}
+
+static int _handle_request_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	if (!apiregmember) {
+	   ERROR0(&quot;got NULL apiregmember&quot;);
+	   return -1;
+	}
+
+    if (apiregmember-&gt;parentemail)
+    	xfree((void *)apiregmember-&gt;parentemail);   /* avoid warning */
+
+	if (param)
+ 	   apiregmember-&gt;request = xstrdup(param);
+
+	return 0;
+}
+
+static int _handle_end_apiregtag(t_apiregmember * apiregmember, char * param)
+{
+	char data[MAX_IRC_MESSAGE_LEN];
+	char temp[MAX_IRC_MESSAGE_LEN];
+	t_connection * conn = apiregmember_get_conn(apiregmember);
+    t_elem * curr;
+ 	t_account * account;
+	char const * newnick = apiregmember_get_newnick(apiregmember);
+	char const * newpass = apiregmember_get_newpass(apiregmember);
+	char const * email = apiregmember_get_email(apiregmember);
+//    char const * newpass2 = apiregmember_get_newpass2(apiregmember);
+	char hresult[11];
+	char message[MAX_IRC_MESSAGE_LEN];
+	char age[7];
+	char consent[11];
+
+   	std::memset(data,0,sizeof(data));
+   	std::memset(temp,0,sizeof(temp));
+
+   	std::memset(hresult,0,sizeof(hresult));
+   	std::memset(message,0,sizeof(message));
+   	std::memset(age,0,sizeof(age));
+   	std::memset(consent,0,sizeof(consent));
+
+   	std::snprintf(hresult,sizeof(hresult),&quot;0&quot;);
+   	std::snprintf(message,sizeof(message),&quot;((Message))&quot;);
+   	std::snprintf(age,sizeof(age),&quot;((Age))&quot;);
+    std::snprintf(consent,sizeof(consent),&quot;((Consent))&quot;);
+
+//   	if (!newnick)
+//   	   std::snprintf(newnick,sizeof(newnick),&quot;((NewNick))&quot;);
+
+//   	if (!newpass)
+//   	   std::snprintf(newpass,sizeof(newpass),&quot;((NewPass))&quot;);
+
+//   	if (!email)
+//   	   std::snprintf(email,sizeof(email),&quot;((Email))&quot;);
+
+	DEBUG3(&quot;APIREG:/%s/%s/%s/&quot;,apiregmember_get_request(apiregmember),apiregmember_get_newnick(apiregmember),apiregmember_get_newpass(apiregmember));
+	
+    //if(!prefs_get_allow_new_accounts()){
+    //message_send_text(conn,message_type_error,conn,&quot;Account creation is not allowed&quot;);
+    //break;
+    //std::snprintf(message,sizeof(message),&quot;Account creation is not allowed&quot;);
+    //std::snprintf(hresult,sizeof(hresult),&quot;-2147221248&quot;);
+
+    if (std::strcmp(apiregmember_get_request(apiregmember), REQUEST_AGEVERIFY) == 0) {
+        std::snprintf(data,sizeof(data),&quot;HRESULT=%s\nMessage=%s\nNewNick=((NewNick))\nNewPass=((NewPass))\n&quot;,hresult,message);
+        /* FIXME: Count real age here! */
+   	    std::snprintf(age,sizeof(age),&quot;28&quot;); /* FIXME: Here must be counted age */
+        std::snprintf(temp,sizeof(temp),&quot;Age=%s\nConsent=((Consent))\nEND\r&quot;,age);
+        std::strcat(data,temp);
+       	apireg_send(apiregmember_get_conn(apiregmember),data);
+       	return 0;
+    }
+    else if (std::strcmp(apiregmember_get_request(apiregmember), REQUEST_GETNICK) == 0) {
+         /*std::snprintf(message,sizeof(message),&quot;Account creation is not allowed&quot;);
+  	     /*std::snprintf(hresult,sizeof(hresult),&quot;-2147221248&quot;);
+        /* Chceck */
+           account = accountlist_find_account(newnick);
+           if (!account) {  // done, we can create new account
+              t_account * tempacct;
+              t_hash bnet_pass_hash;
+              t_wolhash wol_pass_hash;
+
+              // Here we will also check serials and/or emails...
+
+        	  bnet_hash(&amp;bnet_pass_hash,std::strlen(newpass),newpass);
+              wol_hash(&amp;wol_pass_hash,std::strlen(newpass),newpass);
+
+              tempacct = accountlist_create_account(newnick,hash_get_str(bnet_pass_hash));
+
+              if (!tempacct) {
+                  // ERROR: Account is not created! - Why? :)
+                  return 0;
+              }
+              else {
+                  // HASH WOL PASSWORD and save it!
+                  eventlog(eventlog_level_error,__FUNCTION__,&quot;WOLHASH: %s&quot;,wol_pass_hash);
+                  account_set_wol_apgar(tempacct,wol_pass_hash);
+                  account_set_email(tempacct,apiregmember_get_email(apiregmember));
+                  std::snprintf(message,sizeof(message),&quot;Welcome in the amazing world of PvPGN! Your login can be used for all PvPGN Supported games!&quot;);
+              }
+           }
+           else {
+              // Account with this NICK is alredy created!
+              std::snprintf(hresult,sizeof(hresult),&quot;-2147221248&quot;);
+              std::snprintf(message,sizeof(message),&quot;That login is already in use! Please try another NICK name.&quot;);
+           }
+        std::snprintf(data,sizeof(data),&quot;HRESULT=%s\nMessage=%s\nNewNick=%s\nNewPass=%s\nAge=%s\nConsent=0\nEND\r&quot;,hresult,message,newnick,newpass,age,consent);
+       	apireg_send(apiregmember_get_conn(apiregmember),data);
+       	return 0;
+    }
+    else {
+        /* Error: Unknown request - closing connection */
+	    ERROR1(&quot;got UNKNOWN request /%s/ closing connection&quot;,apiregmember-&gt;request);         
+        LIST_TRAVERSE(apireglist(),curr) {
+            t_apiregmember * apiregmemberlist = (t_apiregmember*)elem_get_data(curr);
+
+            if (conn == apiregmember_get_conn(apiregmemberlist))
+               apiregmember_destroy(apiregmember, &amp;curr);
+        }
+
+        conn_set_state(conn, conn_state_destroy);
+        return 0;
+    }
+
+	return 0;
+}
+
+}
+
+}

Added: trunk/pvpgn/src/bnetd/handle_apireg.h
===================================================================
--- trunk/pvpgn/src/bnetd/handle_apireg.h	2007-08-13 10:57:49 UTC (rev 310)
+++ trunk/pvpgn/src/bnetd/handle_apireg.h	2007-08-13 14:03:10 UTC (rev 311)
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2007  Pelish (<A HREF="https://lists.berlios.de/mailman/listinfo/pvpgn-dev">pelish at gmail.com</A>)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef JUST_NEED_TYPES
+
+#ifndef INCLUDED_APIREGISTER_TYPES
+#define INCLUDED_APIREGISTER_TYPES
+
+#include &quot;common/packet.h&quot;
+#include &quot;connection.h&quot;
+#endif
+
+namespace pvpgn
+{
+
+namespace bnetd
+{
+          
+typedef struct apiregmember
+#ifdef APIREGISTER_INTERNAL_ACCESS
+{
+    t_connection *  conn;
+    char const *    email;
+    char const *    bday;
+    char const *    bmonth;
+    char const *    byear;
+    char const *    langcode;
+    char const *    sku;          /* here are SKUs of all installed games */
+    char const *    ver;          /* same as with SKU - versions of all installed games */
+    char const *    serial;       /* also serials of all installed games */
+    char const *    sysid;
+    char const *    syscheck;
+    char const *    oldnick;      /* client send also all nicks that was registerd in the past */
+    char const *    oldpass;      /* and passwords for oldnicks */
+    char const *    newnick;
+    char const *    newpass;
+    char const *    newpass2;
+    char const *    parentemail;
+    bool            newsletter;   /* do user want to sending news by e-mail? */
+    bool            shareinfo;    /* can EA/Westwood shared e-mail contact for sending news? :) */
+    char const *    request;      /* API Register request (knowed requests are defined below) */
+}
+#endif
+t_apiregmember;
+
+#ifndef INCLUDED_HANDLE_APIREG_PROTOS
+#define INCLUDED_HANDLE_APIREG_PROTOS
+
+#define REQUEST_AGEVERIFY    &quot;apireg_ageverify&quot;
+#define REQUEST_GETNICK      &quot;apireg_getnick&quot;
+
+extern int apireglist_create(void);
+extern int apireglist_destroy(void);
+
+extern int handle_apireg_packet(t_connection * conn,t_packet const * const packet);
+
+}
+
+}
+
+#endif
+#endif

Modified: trunk/pvpgn/src/bnetd/handle_irc_common.cpp
===================================================================
--- trunk/pvpgn/src/bnetd/handle_irc_common.cpp	2007-08-13 10:57:49 UTC (rev 310)
+++ trunk/pvpgn/src/bnetd/handle_irc_common.cpp	2007-08-13 14:03:10 UTC (rev 311)
@@ -217,6 +217,10 @@
 
     	eventlog(eventlog_level_debug,__FUNCTION__,&quot;[%d] got \&quot;%s\&quot; \&quot;%s\&quot; [%s] \&quot;%s\&quot;&quot;,conn_get_socket(conn),((prefix)?(prefix):(&quot;&quot;)),command,paramtemp,((text)?(text):(&quot;&quot;)));
 
+    if (conn_get_class(conn) == conn_class_ircinit) {
+	    handle_irc_common_set_class(conn, command, numparams, params, text);
+    }
+
     if (conn_get_state(conn)==conn_state_connected) {
 	t_timer_data temp;
 
@@ -225,10 +229,6 @@
 	conn_test_latency(conn,std::time(NULL),temp);
     }
 
-    if (conn_get_class(conn) == conn_class_ircinit) {
-	    handle_irc_common_set_class(conn, command, numparams, params, text);
-    }
-
 	if (handle_irc_common_con_command(conn, command, numparams, params, text)!=-1) {}
     else if (conn_get_state(conn)!=conn_state_loggedin) {
 	char temp[MAX_IRC_MESSAGE_LEN+1];

Modified: trunk/pvpgn/src/bnetd/irc.cpp
===================================================================
--- trunk/pvpgn/src/bnetd/irc.cpp	2007-08-13 10:57:49 UTC (rev 310)
+++ trunk/pvpgn/src/bnetd/irc.cpp	2007-08-13 14:03:10 UTC (rev 311)
@@ -982,7 +982,7 @@
 	    return -1;
         }
         irc_send_rpl_namreply_internal(c, channel);
-        std:sprintf(temp, &quot;%.32s :End of NAMES list&quot;, ircname);
+        std::sprintf(temp, &quot;%.32s :End of NAMES list&quot;, ircname);
     } else {
         t_elem const * curr;
         LIST_TRAVERSE_CONST(channellist(),curr)

Added: trunk/pvpgn/src/common/wolhash.cpp
===================================================================
--- trunk/pvpgn/src/common/wolhash.cpp	2007-08-13 10:57:49 UTC (rev 310)
+++ trunk/pvpgn/src/common/wolhash.cpp	2007-08-13 14:03:10 UTC (rev 311)
@@ -0,0 +1,109 @@
+/*
+ * Original hash funcions Copyright (C)  Luigi Auriemma (<A HREF="https://lists.berlios.de/mailman/listinfo/pvpgn-dev">aluigi at autistici.org</A>)
+ * Copyright (C) 2007  Pelish (<A HREF="https://lists.berlios.de/mailman/listinfo/pvpgn-dev">pelish at gmail.com</A>)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include &quot;common/setup_before.h&quot;
+#include &quot;common/wolhash.h&quot;
+
+#include &lt;cstdlib&gt;
+#include &lt;cstring&gt;
+
+#include &quot;common/eventlog.h&quot;
+#include &quot;common/setup_after.h&quot;
+
+namespace pvpgn
+{
+
+
+extern int wol_hash(t_wolhash * hashout, unsigned int size, void const * datain) {
+    unsigned char pwd1[9];
+    unsigned char pwd2[9];
+    unsigned char edx;
+    unsigned char esi;
+    unsigned char i;
+    unsigned char *p1;
+    unsigned char *p2;
+
+   /**
+    * Original NOTE by Luigi Auriemma:
+    * Original algorithm starts at offset 0x0041d440 of wchat.dat of 4.221 US version
+    * The algorithm is one-way, so the encoded password can NOT be completely decoded!
+    */
+
+    if(size &gt; 8) {
+//        ERROR1(&quot;Westwood passwords are max 8 bytes long: \&quot;%.8s\&quot;&quot;,size);
+        return -1;
+    }
+    
+    if (!datain) {
+	    ERROR0(&quot;got NULL datain&quot;);
+        return -1;
+    }
+
+    std::memset(pwd1, 0, sizeof(pwd1));
+    std::memset(pwd2, 0, sizeof(pwd2));
+    std::memcpy(pwd1, datain, size);
+
+    esi = size;
+    p1 = pwd1;
+    p2 = pwd2;
+    for(i = 0; i &lt; size; i++) {
+        if(*p1 &amp; 1) {
+            edx = *p1 &lt;&lt; 1;
+            edx &amp;= *(pwd1 + esi);
+        } 
+        else {
+            edx = *p1 ^ *(pwd1 + esi);
+        }
+        *p2++ = edx;
+        esi--;
+        p1++;
+    }
+
+    p1 = pwd1;
+    p2 = pwd2;
+    for(i = 0; i &lt; 8; i++) {
+        edx = *p2++ &amp; 0x3f;
+        *p1++ = WOL_HASH_CHAR[edx];
+    }
+
+    std::memcpy(hashout, pwd1, sizeof(pwd1));
+    return 0;
+}
+    
+/*extern int wolhash_eq(t_wolhash const h1, t_wolhash const h2)
+{
+    unsigned int i;
+
+    if (!h1 || !h2)
+    {
+	eventlog(eventlog_level_error,__FUNCTION__,&quot;got NULL hash&quot;);
+	return -1;
+    }
+
+    for (i=0; i&lt;5; i++)
+	if (h1[i]!=h2[i])
+	    return 0;
+
+    return 1;
+}*/
+
+}
+
+
+

Added: trunk/pvpgn/src/common/wolhash.h
===================================================================
--- trunk/pvpgn/src/common/wolhash.h	2007-08-13 10:57:49 UTC (rev 310)
+++ trunk/pvpgn/src/common/wolhash.h	2007-08-13 14:03:10 UTC (rev 311)
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2007  Pelish (<A HREF="https://lists.berlios.de/mailman/listinfo/pvpgn-dev">pelish at gmail.com</A>)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+#ifndef INCLUDED_WOLHASH_TYPES
+#define INCLUDED_WOLHASH_TYPES
+
+#ifdef JUST_NEED_TYPES
+# include &quot;compat/uint.h&quot;
+#else
+# define JUST_NEED_TYPES
+# include &quot;compat/uint.h&quot;
+# undef JUST_NEED_TYPES
+#endif
+
+namespace pvpgn
+{
+
+typedef char t_wolhash[9];
+
+}
+
+#endif
+
+/*****/
+#define WOL_HASH_CHAR    &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789./&quot;
+
+#ifndef JUST_NEED_TYPES
+#ifndef INCLUDED_WOLHASH_PROTOS
+#define INCLUDED_WOLHASH_PROTOS
+
+
+namespace pvpgn
+{
+
+extern int wol_hash(t_wolhash * hashout, unsigned int size, void const * datain);
+//extern int wolhash_eq(t_wolhash const h1, t_wolhash const h2) ;
+
+}
+
+#endif
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000287.html">[pvpgn-dev] r310 - trunk/pvpgn/src/bnetd
</A></li>
	<LI>Next message: <A HREF="000289.html">[pvpgn-dev] r312 - trunk/pvpgn/conf
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#288">[ date ]</a>
              <a href="thread.html#288">[ thread ]</a>
              <a href="subject.html#288">[ subject ]</a>
              <a href="author.html#288">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/pvpgn-dev">More information about the pvpgn-dev
mailing list</a><br>
</body></html>
